<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM 对象布局</title>
      <link href="2021/04/29/JVM%20%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80.html"/>
      <url>2021/04/29/JVM%20%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80.html</url>
      
        <content type="html"><![CDATA[<p>tags:</p><ul><li>jvm</li><li>对象头</li></ul><h1 id="对象布局图解析"><a href="#对象布局图解析" class="headerlink" title="对象布局图解析"></a>对象布局图解析</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/105968/1619666460871-3d1fbbdd-fb1b-4b1a-8691-d82812efd13d.png#clientId=u71e0b6f2-65f2-4&from=paste&height=544&id=uce2a3a3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=544&originWidth=1005&originalType=binary&size=103200&status=done&style=none&taskId=u31e7a895-3a50-4a8d-aa63-66db6cd3e07&width=1005" alt="image.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql的一些设计规范及Explain工具解析</title>
      <link href="2021/04/29/MySql%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E5%8F%8AExplain%E5%B7%A5%E5%85%B7%E8%A7%A3%E6%9E%90.html"/>
      <url>2021/04/29/MySql%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E5%8F%8AExplain%E5%B7%A5%E5%85%B7%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySql-设计规范"><a href="#MySql-设计规范" class="headerlink" title="MySql 设计规范"></a>MySql 设计规范</h1><ol><li><p>必须使用 InnoDB 存储引擎，非特殊要求一律使用此引擎</p><blockquote><p>支持事务、行级锁、并发性能更好、CPU 及内存缓存页优化使得资源利用率更高</p></blockquote></li><li><p>必须使用 utf8(utf8mb4)字符集</p><blockquote><p>万国码，无需转码，无乱码风险，节省空间，utf8mb4 是 utf8 的超集，emoji 表情以及部分不常见汉字在 utf8 下会表现为乱码，故需要升级至 utf8mb4，mb4 即 most bytes 4，用四个字节存储更多的字符</p></blockquote></li><li><p>数据表、数据字段必须加入中文注释</p><blockquote><p>N 年后谁会知道这个 a1,a2,a3 字段是干嘛的</p></blockquote></li><li><p>禁止使用存储过程、视图、触发器、Event</p><blockquote><p>高并发大数据的互联网业务，架构设计思路是“解放数据库 CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU 计算还是上移吧</p></blockquote></li><li><p>禁止存储大文件或者大照片</p><blockquote><p>为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存 URI 多好</p></blockquote></li><li><p>库名、表名、字段名：小写，下划线风格，不超过 32 个字符，禁止拼音英文混用</p><blockquote><p>见名知意，方便后续维护</p></blockquote></li><li><p>表必须包含物理主键 id 列，主键必须自增长（auto_increment），禁止使用 varchar 作为主键，如主键字段不能满足业务需求，另建 unique 约束业务字段</p><blockquote><ul><li>主键递增，数据行写入可以提高插入性能，可以避免 page 分裂，减少表碎片提升空间和内存的使用</li><li>主键要选择较短的数据类型， Innodb 引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率</li><li>无主键的表删除，在 row 模式的主从架构，会导致备库夯住</li></ul></blockquote></li><li><p>索引命名约定：主键：pk_columnName (或者让数据库自动命名); 唯一键：uniq_columnName; 普通索引：idx_columnName; 组合索引：idx_column1_column2_Column3</p><blockquote><p>见名知意，方便后续维护</p></blockquote></li><li><p>禁止使用强外键，如果有外键完整性约束，在应用程序中控制</p><blockquote><p>强外键会导致表与表之间耦合，update 与 delete 操作都会涉及相关联的表，十分影响 sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先</p></blockquote></li><li><p>尽量把字段定义为 NOT NULL 并且提供默认值</p><blockquote><ul><li>null 的列使索引/索引统计/值比较都更加复杂，对 MySQL 来说更难优化</li><li>null 这种类型 MySQL 内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多</li><li>null 值需要更多的存储空间，无论是表还是索引中每行中的 null 的列都需要额外的空间来标识</li><li>对 null 的处理时候，只能采用 is null 或 is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in 这些操作符号。如：where name!=’crm’，如果存在 name 为 null 值的记录，查询结果就不会包含 name 为 null 值的记录</li></ul></blockquote></li><li><p>禁止使用 TEXT、BLOB 类型</p><blockquote><p>原则上不允许这种字段，尽可能的拆分成小字段，如果特别需要，而又读写频繁，另外建一张表<br>会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能</p></blockquote></li><li><p>金额存储使用 decimel(xx,2)</p><blockquote><ul><li>网上建议使用：使用“分”作为单位，这样数据库里就是整数了</li><li>DECIMAL(M,D)中，M 范围是 1 到 65，D 范围是 0 到 30。</li><li>M 默认为 10，D 默认为 0，D 不大于 M。</li><li>DECIMAL(5,2)可存储范围是从-999.99 到 999.99，超出存储范围会报错。</li><li>存储数值时，小数位不足会自动补 0，首位数字为 0 自动忽略。</li><li>小数位超出会截断，产生告警，并按四舍五入处理。</li><li>使用 DECIMAL 字段时，建议 M，D 参数手动指定，并按需分配</li></ul></blockquote></li><li><p>使用 varchar(20)存储手机号</p><blockquote><ul><li>涉及到区号或者国家代号，可能出现+-()</li><li>手机号会去做数学运算么？有必要用 bigint 么？</li><li>varchar 可以支持模糊查询，例如：like“138%”</li></ul></blockquote></li><li><p>禁止使用 ENUM（枚举），可使用 TINYINT 代替</p><blockquote><ul><li>增加新的 ENUM 值要做 DDL 操作</li><li>ENUM 的内部实际存储就是整数，你以为自己定义的是字符串？</li></ul></blockquote></li><li><p>优先选择符合存储需要的最小的数据类型</p><blockquote><p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多， 索引的性能也就越差</p></blockquote></li><li><p>将字符串转换成数字类型存储，如：将 IP 地址转换成整形数据</p><blockquote><p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间<br>显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可</p></blockquote></li><li><p>对于非负型的数据（如自增 ID、整型 IP）来说，要优先使用无符号整型来存储(UNSIGNED)</p><blockquote><p>无符号相对于有符号可以多出一倍的存储空间</p><ul><li>SIGNED INT -2147483648~2147483647</li><li>UNSIGNED INT 0~4294967295</li></ul></blockquote></li><li><p>单表索引建议控制在 5 个以内，单索引字段数不允许超过 5 个</p><blockquote><ul><li>一个好的索引设计，可以让你的效率提高几十甚至几百倍，但过多反而适得其反</li><li>字段超过 5 个时，实际已经起不到有效过滤数据的作用了</li></ul></blockquote></li><li><p>禁止在更新十分频繁、区分度不高的属性上建立索引</p><blockquote><ul><li>更新会变更 B+树，更新频繁的字段建立索引会大大降低数据库性能</li><li>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</li></ul></blockquote></li><li><p>建立组合索引，必须把区分度高的字段放在前面</p><blockquote><p>能够更加有效的过滤数据、命中索引</p></blockquote></li><li><p>禁止使用 SELECT *，只获取必要的字段，需要显示说明列属性</p><blockquote><ul><li>读取不需要的列会增加 CPU、IO、网络消耗</li><li>不能有效的利用覆盖索引</li><li>使用 SELECT *容易在增加或者删除字段后出现程序 BUG</li></ul></blockquote></li><li><p>禁止使用 INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</p><blockquote><p>容易在增加或者删除字段后出现程序 BUG</p></blockquote></li><li><p>禁止使用属性隐式转换</p><blockquote><p>SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中 phone 索引； int 数据类型优先级高于 varchar， 该查询会把 phone 转换为 int，因此需要把表中所有数据改成 int，所以必须全盘扫描 phone 是 varchar 类型，SQL 语句带入的是整形，故不会命中索引，加个引号就好了： SELECT uid FROM t_user WHERE phone=’13812345678’</p></blockquote></li><li><p>禁止在 WHERE 条件的属性上使用函数或者表达式</p><blockquote><p>SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描 正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p></blockquote></li><li><p>禁止大表使用 JOIN 查询（大表驱动），禁止大表使用子查询</p><blockquote><p>会产生临时表，消耗较多内存与 CPU，极大影响数据库性能，大表一般是指 1000 万级以上数据量</p></blockquote></li><li><p>禁止使用 OR 条件，必须改为 IN 查询</p><blockquote><p>旧版本 Mysql 的 OR 查询是不能命中索引的，即使能命中索引（同表走索引），为何要让数据库耗费更多的 CPU 帮助实施查询优化呢？ 可以使用 IN 或 Union All 优化</p></blockquote></li><li><p>禁止使用负向查询，以及%开头的模糊查询</p><blockquote><ul><li>负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE 等，会导致全表扫描</li><li>%开头的模糊查询，会导致全表扫描 往往 WHERE 过滤条件不会只带这么一个“负向查询条件”，还会有其他过滤条件，举个例子：查询 risfeng 已完成订单之外的订单： SELECT oid FROM t_order WHERE uid=123 AND status != 1; 订单表 5000w 数据，但 uid=123 就会迅速的将数据量过滤到很少的级别（uid 建立了索引），此时再接上一个负向的查询条件就无所谓了，扫描的行数本身就会很少 ,但如果要查询所有已完成订单之外的订单： SELECT oid FROM t_order WHERE status != 1; 这就挂了，CPU 立马飙升，status 索引会失效，负向查询导致全表扫描</li></ul></blockquote></li><li><p>在明显不会有重复值时使用 UNION ALL 而不是 UNION</p><blockquote><ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>UNION ALL 不会再对结果集进行去重操作</li></ul></blockquote></li><li><p>不允许使用的常见列名</p><blockquote><p><code>status</code>,<code>order</code>,<code>desc</code>,<code>type</code>,<code>add</code>,<code>and</code>,<code>all</code>,<code>both</code>,<code>is_delete</code>,<code>row</code>,<code>delayed</code>,<code>group</code>,<br><code>if</code>,<code>set</code>,<code>system</code>,<code>undo</code>,<code>unique</code>,<code>with</code>,<code>specific</code>,<code>dec</code>,<code>label</code>,<code>modifies</code>,<code>both</code>,<code>continue</code>,<br><code>compute</code>,<code>keep</code>,<code>loop</code>,<code>leave</code>,<code>match</code>,<code>optimize</code>,<code>over</code>,<code>rows</code>,<code>session</code>,<code>show</code>,<code>force</code>,<code>following</code>,<br><code>exists</code>,<code>do</code>,<code>div</code>,<code>delete</code>,<code>insert</code>,<code>select</code>,<code>create</code>,<code>table</code>,<code>cursor</code>,<code>column</code>,<code>columns</code>,<code>cross</code>,<code>current</code>,<br><code>condition</code>,<code>check</code>,<code>change</code>,<code>admin</code></p></blockquote></li><li><p>每张表的公共字段</p><blockquote><ul><li>每张表包含 2 个公共字段，created_at，updated_at</li><li>is_delete 作为标识记录逻辑删除，非必须字段，枚举类型，0 有效，1 删除，默认为 0（有效），如数据量增长过大可通过归档，归档后在表中物理删除。</li><li>created_at,updated_at 字段作为 DT 增量拉取数据和数据回退等场景下使用，created_at 默认 current_timestamp</li><li>updated_at 默认 current_timestamp，on update current_timestamp</li><li>例如：</li></ul><p>created_at datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT ‘创建时间’,<br>updated_at datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE                                                       CURRENT_TIMESTAMP COMMENT ‘更新时间’,<br>is_delete tinyint(4) NOT NULL DEFAULT ‘0’ COMMENT ‘逻辑删除标记’</p></blockquote></li><li><p>字段冗余</p><blockquote><p>非严格遵守 3NF，通过业务字段冗余来减少表关联</p></blockquote></li><li><p>日期</p><blockquote><ul><li>datetime 占 8 个字节，支持 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’，默认值非 current_timestamp()下，建议设置为’1970-01-01 08:00:01’。</li><li>timestamp 占 4 字节，能表示最大的时间毫秒为 231-1=2147483647，换成时间刚好是 2038-01-19 03:14:07.999999。支持’1970-01-01 00:00:01’到 ‘2038-01-19 03:14:07’ UTC，建表时该字段不加任何属性时默认加非空约束，default 值为 current_timestamp，默认值非 current_timestamp()下，建议设置成’1970-01-01 08:00:01’。</li><li>date 类型,默认值非 current_date()下，建议默认值为’1970-01-01’。</li><li>一张表只能有一个 timestamp 列用于标识自动更新，长度不允许自定义，非自动更新的列建议统一使用 datetime。</li></ul></blockquote></li><li><p>必须包含索引的字段：公共字段 created_at 和 updated_at 必须建立索引</p><blockquote><p>这 2 列经常会用作同步数据或回退数据使用</p></blockquote></li><li><p>数据批量导入时需要控制数据量</p><blockquote><p>数据量过大会长时间占用事务资源，导致其他小事务长时间等待；数据量太小也失去批量的意义。</p></blockquote></li><li><p>涉及到大量数据迁移时请选择业务低峰期</p><blockquote><p>一般选择在半夜 12 点后执行此类动作</p></blockquote></li></ol><hr><h1 id="Explain-工具解析"><a href="#Explain-工具解析" class="headerlink" title="Explain 工具解析"></a>Explain 工具解析</h1><h2 id="了解一下-MySql-索引数据存储结构"><a href="#了解一下-MySql-索引数据存储结构" class="headerlink" title="了解一下 MySql 索引数据存储结构"></a>了解一下 MySql 索引数据存储结构</h2><ol><li>推荐一个学习数据结构可视化站点：旧金山大学：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></li><li>数据储存物理文件：<ol><li>MyISAM:物理文件有 3 个：.frm .myi .myd</li><li>InnoDb：物理文件有 2 个：.frm .ibd</li></ol></li><li>B-Tree 索引数据结构图</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605161234881-1b07ff86-b307-4000-bd5e-cf87ce2895e5.png#height=185&id=n0KpA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=369&originWidth=1280&originalType=binary&size=126983&status=done&style=none&width=640" alt="image.png"></p><ol start="3"><li>B+Tree（B-Tree 变种）索引数据结构图<ol><li>非叶子节点不存储 data，只存储索引(冗余)，可以放更多的索引</li><li>叶子节点包含所有索引字段</li><li>叶子节点用指针连接，提高区间访问的性能</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605161349189-51832bda-06bb-4cb2-a2c8-8206ff98a6e2.png#height=255&id=YXmBt&margin=%5Bobject%20Object%5D&name=image.png&originHeight=509&originWidth=1280&originalType=binary&size=139307&status=done&style=none&width=640" alt="image.png"></p><ol start="4"><li>MyISAM 索引文件和数据文件是分离的(非聚集)</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605161385061-c9d85c3e-5d51-4ebe-a0ac-1d2d85760d7a.png#height=497&id=Ctzvp&margin=%5Bobject%20Object%5D&name=image.png&originHeight=994&originWidth=1280&originalType=binary&size=215137&status=done&style=none&width=640" alt="image.png"></p><ol start="5"><li>InnoDB 索引实现(聚集索引+非聚集索引)<ol><li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li><li>聚集索引-叶子节点包含了完整的数据记录</li><li>为什么 InnoDB 表必须有主键，并且推荐使用整型的自增主键？<ol><li>如果设置了主键，那么 InnoDB 会选择主键作为聚集索引、如果没有显式定义主键，则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引、如果也没有这样的唯一索引，则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐含的聚集索引(ROWID 随着行记录的写入而主键递增)</li><li>如果表使用自增主键那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，主键的顺序按照数据记录的插入顺序排列，自动有序。当一页写满，就会自动开辟一个新的页</li><li>如果使用非自增主键（如 uuid、身份证号等）由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时 MySQL 不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。</li></ol></li><li>为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)</li><li>为什么 mysql 页文件默认 16K？<ol><li>查看 mysql 文件页大小（16K）：SHOW GLOBAL STATUS like ‘Innodb_page_size’;</li><li>不建议修改，mysql 设置为 16K 是通过各方面考虑、验证、衡量的结果；</li><li>计算一下：假设我们一行数据大小为 1K，那么一页就能存 16 条数据，也就是一个叶子节点能存 16 条数据；再看非叶子节点，假设主键 ID 为 bigint 类型，那么长度为 8B，指针大小在 Innodb 源码中为 6B，一共就是 14B，那么一页里就可以存储 16K/14=1170 个(主键+指针) 那么一颗高度为 2 的 B+树能存储的数据为：1170<em>16=18720 条，一颗高度为 3 的 B+树能存储的数据为：1170</em>1170*16=21902400（千万级条）</li></ol></li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605164668995-abdfbbfb-20f1-4e12-aae1-5d3042873190.png#height=280&id=Tjd4n&margin=%5Bobject%20Object%5D&name=image.png&originHeight=560&originWidth=1280&originalType=binary&size=152473&status=done&style=none&width=640" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605164677572-7220baac-2992-4205-84c7-b7d8f9bae626.png#height=275&id=z2rPW&margin=%5Bobject%20Object%5D&name=image.png&originHeight=550&originWidth=1280&originalType=binary&size=149280&status=done&style=none&width=640" alt="image.png"></p><ol start="6"><li>联合索引的底层存储结构</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605166824747-d602a564-3749-477c-811b-ba6eebd816b1.png#height=295&id=VpwZI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=589&originWidth=1280&originalType=binary&size=205770&status=done&style=none&width=640" alt="image.png"></p><h2 id="Explain-工具介绍"><a href="#Explain-工具介绍" class="headerlink" title="Explain 工具介绍"></a>Explain 工具介绍</h2><p>使用 EXPLAIN 关键字可以模拟优化器执行 SQL 语句，分析你的查询语句或是结构的性能瓶颈<br>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条 SQL 注意：如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中</p><h3 id="Explain-分析示例"><a href="#Explain-分析示例" class="headerlink" title="Explain 分析示例"></a>Explain 分析示例</h3><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 示例表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> actor<span class="token punctuation">(</span>    id          <span class="token keyword">INT</span>         <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    name        <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    update_time <span class="token keyword">DATETIME</span>    <span class="token boolean">NULL</span><span class="token punctuation">)</span>  <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 示例数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> my_demo<span class="token punctuation">.</span>actor <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> update_time<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'2020-11-06 00:59:54'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> my_demo<span class="token punctuation">.</span>actor <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> update_time<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'2020-11-06 00:59:54'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> my_demo<span class="token punctuation">.</span>actor <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> update_time<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'2020-11-06 00:59:54'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> film<span class="token punctuation">(</span>    id   <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span>  <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_name <span class="token keyword">ON</span> film <span class="token punctuation">(</span> name <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> my_demo<span class="token punctuation">.</span>film <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'film 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> my_demo<span class="token punctuation">.</span>film <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'film0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> my_demo<span class="token punctuation">.</span>film <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'film1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> film_actor<span class="token punctuation">(</span>    id       <span class="token keyword">INT</span>          <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    film_id  <span class="token keyword">INT</span>          <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    actor_id <span class="token keyword">INT</span>          <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    remark   <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_film_actor_id <span class="token keyword">ON</span> film_actor <span class="token punctuation">(</span> film_id<span class="token punctuation">,</span> actor_id <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> my_demo<span class="token punctuation">.</span>film_actor <span class="token punctuation">(</span>id<span class="token punctuation">,</span> film_id<span class="token punctuation">,</span> actor_id<span class="token punctuation">,</span> remark<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> my_demo<span class="token punctuation">.</span>film_actor <span class="token punctuation">(</span>id<span class="token punctuation">,</span> film_id<span class="token punctuation">,</span> actor_id<span class="token punctuation">,</span> remark<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> my_demo<span class="token punctuation">.</span>film_actor <span class="token punctuation">(</span>id<span class="token punctuation">,</span> film_id<span class="token punctuation">,</span> actor_id<span class="token punctuation">,</span> remark<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行如下语句会得到分析结果，下面会根据如下结果分析。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor<span class="token punctuation">;</span></code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605176244573-d5e28ee0-8a0f-43e9-8a78-55003233e165.png#height=118&id=OZe3n&margin=%5Bobject%20Object%5D&name=image.png&originHeight=118&originWidth=1493&originalType=binary&size=19714&status=done&style=stroke&width=1493" alt="image.png"></p><h4 id="Explain-中的列分析"><a href="#Explain-中的列分析" class="headerlink" title="Explain 中的列分析"></a>Explain 中的列分析</h4><ol><li><p><strong>Id 列</strong></p><blockquote><ul><li>id 列的编号是 select 的序列号，有几个 select 就有几个 id，并且 id 的顺序是按 select 出现的顺序增长的。</li><li>id 列越大执行优先级越高，id 相同则从上往下执行，id 为 NULL 最后执行。</li></ul></blockquote></li><li><p><strong>select_type 列：</strong></p><blockquote><p>表示对应行是简单还是复杂的查询。</p></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token number">1</span>）<span class="token keyword">simple</span>：简单查询。查询不包含子查询和<span class="token keyword">union</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token number">2</span>）<span class="token keyword">primary</span>：复杂查询中最外层的 <span class="token keyword">select</span><span class="token number">3</span>）subquery：包含在 <span class="token keyword">select</span> 中的子查询（不在 <span class="token keyword">from</span> 子句中）<span class="token number">4</span>）derived：包含在 <span class="token keyword">from</span> 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）用下面来这个SQL来了解<span class="token keyword">primary</span>、subquery和derived类型<span class="token comment" spellcheck="true">#关闭mysql5.7+新特性对衍 生表的合并优化</span><span class="token keyword">set</span> <span class="token keyword">session</span> optimizer_switch<span class="token operator">=</span><span class="token string">'derived_merge=off'</span><span class="token punctuation">;</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> actor <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> der<span class="token punctuation">;</span><span class="token comment" spellcheck="true">#还原默认配置</span><span class="token keyword">set</span> <span class="token keyword">session</span> optimizer_switch<span class="token operator">=</span><span class="token string">'derived_merge=on'</span><span class="token punctuation">;</span><span class="token number">5</span>）<span class="token keyword">union</span>：在 <span class="token keyword">union</span> 中的第二个和随后的 <span class="token keyword">select</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">union</span> <span class="token keyword">all</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><ol start="3"><li><strong>table 列</strong><blockquote><ul><li>这一列表示 explain 的一行正在访问哪个表。</li><li>当 from 子句中有子查询时，table 列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。</li><li>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1 和 2 表示参与 union 的 select 行 id。</li></ul></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">UNION</span>  <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">UNION</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><ol start="4"><li>** type 列：**<blockquote><p>这一列表示关联类型或访问类型，即 MySQL 决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：null&gt;system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL  <br>一般来说，得保证查询达到 range 级别，最好达到 ref</p></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token number">1</span>）<span class="token boolean">null</span>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token function">min</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">from</span> film<span class="token punctuation">;</span><span class="token number">2</span>）system，const：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看<span class="token keyword">show</span> <span class="token keyword">warnings</span> 的结果）。用于 <span class="token keyword">primary</span> <span class="token keyword">key</span> 或 <span class="token keyword">unique</span> <span class="token keyword">key</span> 的所有列与常数比较时，所以表最多 有一个匹配行，读取<span class="token number">1</span>次，速度比较快。system是const的特例，表里只有一条元组匹配时为<span class="token keyword">set</span> <span class="token keyword">session</span> optimizer_switch<span class="token operator">=</span><span class="token string">'derived_merge=off'</span><span class="token punctuation">;</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> tmp<span class="token punctuation">;</span><span class="token keyword">show</span> <span class="token keyword">warnings</span><span class="token punctuation">;</span><span class="token number">3</span>）eq_ref：<span class="token keyword">primary</span> <span class="token keyword">key</span> 或 <span class="token keyword">unique</span> <span class="token keyword">key</span> 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 <span class="token keyword">select</span> 查询不会出现这种<span class="token keyword">type</span>。<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film_actor <span class="token keyword">left</span> <span class="token keyword">join</span> film <span class="token keyword">on</span> film_actor<span class="token punctuation">.</span>film_id <span class="token operator">=</span> film<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span class="token number">4</span>）ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。<span class="token number">a</span><span class="token punctuation">.</span> 简单 <span class="token keyword">select</span> 查询，name是普通索引（非唯一索引）<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'film1'</span><span class="token punctuation">;</span><span class="token number">b</span><span class="token punctuation">.</span>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。<span class="token keyword">explain</span> <span class="token keyword">select</span> film_id <span class="token keyword">from</span> film <span class="token keyword">left</span> <span class="token keyword">join</span> film_actor <span class="token keyword">on</span> film<span class="token punctuation">.</span>id <span class="token operator">=</span> film_actor<span class="token punctuation">.</span>film_id<span class="token punctuation">;</span><span class="token number">5</span>）range：范围扫描通常出现在 <span class="token operator">in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">between</span> <span class="token punctuation">,</span><span class="token operator">></span> <span class="token punctuation">,</span><span class="token operator">&lt;</span><span class="token punctuation">,</span> <span class="token operator">>=</span> 等操作中。使用一个索引来检索给定 范围的行。<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor <span class="token keyword">where</span> id <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">6</span>）<span class="token keyword">index</span>：扫描全表索引，这通常比<span class="token keyword">ALL</span>快一些。<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film<span class="token punctuation">;</span><span class="token number">7</span>）<span class="token keyword">ALL</span>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor<span class="token punctuation">;</span></code></pre><ol start="5"><li><p>** possible_keys 列**</p><blockquote><p>这一列显示查询可能使用哪些索引来查找。 explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中 数据不多，mysql 认为索引对此查询帮助不大，选择了全表查询。 如果该列是 NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可 以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p></blockquote></li><li><p>** key 列**</p><blockquote><p>这一列显示 mysql 实际采用哪个索引来优化对该表的访问。 如果没有使用索引，则该列是 NULL。如果想强制 mysql 使用或忽视 possible_keys 列中的索引，在查询中使用 force index、ignore index。</p></blockquote></li><li><p>** key_len 列**</p><blockquote><p>这一列显示了 mysql 在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。举例来说，film_actor 的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个 int 列组成， 并且每个 int 是 4 字节。通过结果中的 key_len=4 可推断出查询使用了第一个列：film_id 列来执 行索引查找。</p></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film_actor <span class="token keyword">where</span> film_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>key_len计算规则如下：<span class="token number">1</span>）字符串char<span class="token punctuation">(</span>n<span class="token punctuation">)</span>：n字节长度<span class="token keyword">varchar</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>：<span class="token number">2</span>字节存储字符串长度，如果是utf<span class="token number">-8</span>（<span class="token number">1</span><span class="token operator">-</span><span class="token number">3</span>个字节）utf<span class="token operator">-</span>8mb4<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">4</span>个字节<span class="token punctuation">)</span>，则长度 3n <span class="token operator">+</span> <span class="token number">2</span>（<span class="token operator">&lt;</span><span class="token number">255</span>使用<span class="token number">1</span>个字节存储长度 <span class="token operator">></span><span class="token number">255</span>使用<span class="token number">2</span>个字节存储长度）<span class="token number">2</span>）数值类型<span class="token keyword">tinyint</span>：<span class="token number">1</span>字节<span class="token keyword">smallint</span>：<span class="token number">2</span>字节<span class="token keyword">int</span>：<span class="token number">4</span>字节<span class="token keyword">bigint</span>：<span class="token number">8</span>字节<span class="token number">3</span>）时间类型<span class="token keyword">date</span>：<span class="token number">3</span>字节<span class="token keyword">timestamp</span>：<span class="token number">4</span>字节<span class="token keyword">datetime</span>：<span class="token number">8</span>字节<span class="token number">4</span>）如果字段允许为 <span class="token boolean">NULL</span>，需要<span class="token number">1</span>字节记录是否为 <span class="token boolean">NULL</span>索引最大长度是<span class="token number">768</span>字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</code></pre><ol start="8"><li><p><strong>ref 列</strong></p><blockquote><p>这一列显示了在 key 列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p></blockquote></li><li><p>** rows 列**</p><blockquote><p>这一列是 mysql 估计要读取并检测的行数，注意这个不是结果集里的行数。</p></blockquote></li><li><p><strong>filtered 列</strong></p><blockquote><p>是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表 进行连接的行数（前一个表指 explain 中的 id 值比当前表 id 值小的表）</p></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">explain</span>  <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><ol start="11"><li><strong>Extra 列</strong><blockquote><p>这一列展示的是额外信息。常见的重要值如下：</p></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token number">1</span>）<span class="token keyword">Using</span> <span class="token keyword">index</span>：使用覆盖索引<span class="token keyword">explain</span> <span class="token keyword">select</span> film_id <span class="token keyword">from</span> film_actor <span class="token keyword">where</span> film_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">2</span>）<span class="token keyword">Using</span> <span class="token keyword">where</span>：使用 <span class="token keyword">where</span> 语句来处理结果，查询的列未被索引覆盖<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token number">3</span>）<span class="token keyword">Using</span> <span class="token keyword">index</span> condition：查询的列不完全被索引覆盖，<span class="token keyword">where</span>条件中是一个前导列的范 围；<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film_actor <span class="token keyword">where</span> film_id <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">4</span>）<span class="token keyword">Using</span> <span class="token keyword">temporary</span>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。<span class="token number">a</span><span class="token punctuation">)</span> actor<span class="token punctuation">.</span>name没有索引，此时创建了张临时表来<span class="token keyword">distinct</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token keyword">distinct</span> name <span class="token keyword">from</span> actor<span class="token punctuation">;</span><span class="token number">b</span><span class="token punctuation">)</span> film<span class="token punctuation">.</span>name建立了idx_name索引，此时查询时extra是<span class="token keyword">using</span> <span class="token keyword">index</span><span class="token punctuation">,</span>没有用临时表<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token keyword">distinct</span> name <span class="token keyword">from</span> film<span class="token punctuation">;</span><span class="token number">5</span>） <span class="token keyword">Using</span> filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。<span class="token number">a</span><span class="token punctuation">)</span> actor<span class="token punctuation">.</span>name未创建索引，会查询actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录 <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor <span class="token keyword">order</span> <span class="token keyword">by</span> name<span class="token punctuation">;</span><span class="token number">b</span><span class="token punctuation">)</span>  film<span class="token punctuation">.</span>name建立了idx_name索引<span class="token punctuation">,</span>此时查询时extra是<span class="token keyword">using</span> <span class="token keyword">index</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> film <span class="token keyword">order</span> <span class="token keyword">by</span> name<span class="token punctuation">;</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token keyword">Select</span> <span class="token keyword">tables</span> optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段，<span class="token keyword">table</span>列显示为<span class="token boolean">Null</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span>操作已经优化到不能再优化了<span class="token punctuation">)</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token function">min</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">from</span> film<span class="token punctuation">;</span></code></pre><h2 id="索引最佳实践"><a href="#索引最佳实践" class="headerlink" title="索引最佳实践"></a>索引最佳实践</h2><h3 id="示例表"><a href="#示例表" class="headerlink" title="示例表"></a>示例表</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>employees<span class="token punctuation">`</span><span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span>        <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>     <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>name<span class="token punctuation">`</span>      <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'姓名'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>age<span class="token punctuation">`</span>       <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>     <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span> <span class="token keyword">COMMENT</span> <span class="token string">'年龄'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>position<span class="token punctuation">`</span>  <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span> <span class="token keyword">COMMENT</span> <span class="token string">'职位'</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>hire_time<span class="token punctuation">`</span> <span class="token keyword">TIMESTAMP</span>   <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">COMMENT</span> <span class="token string">'入职时 间'</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_name_age_position<span class="token punctuation">`</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>age<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>position<span class="token punctuation">`</span> <span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span> <span class="token operator">=</span> utf8 <span class="token keyword">COMMENT</span> <span class="token operator">=</span><span class="token string">'员工记录表'</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> employees<span class="token punctuation">(</span> NAME<span class="token punctuation">,</span> age<span class="token punctuation">,</span> position<span class="token punctuation">,</span> hire_time <span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span> <span class="token string">'LiLei'</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token string">'manager'</span><span class="token punctuation">,</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> employees<span class="token punctuation">(</span> NAME<span class="token punctuation">,</span> age<span class="token punctuation">,</span> position<span class="token punctuation">,</span> hire_time <span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span> <span class="token string">'HanMeimei'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token string">'dev'</span><span class="token punctuation">,</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> employees<span class="token punctuation">(</span> NAME<span class="token punctuation">,</span> age<span class="token punctuation">,</span> position<span class="token punctuation">,</span> hire_time <span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span> <span class="token string">'Lucy'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token string">'dev'</span><span class="token punctuation">,</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li><strong>全值匹配</strong></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'LiLei'</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'LiLei'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'LiLei'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">22</span> <span class="token operator">AND</span> position <span class="token operator">=</span><span class="token string">'manager'</span><span class="token punctuation">;</span></code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605184485308-22436b95-4263-495f-88f4-a400c7313c74.png#height=348&id=TpWVG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=348&originWidth=2178&originalType=binary&size=74684&status=done&style=stroke&width=2178" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605184577319-b068e55b-8e0a-44b5-80a6-26c52679bb0e.png#height=322&id=cB2XA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=2198&originalType=binary&size=74925&status=done&style=stroke&width=2198" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/105968/1605184623260-31f782c3-4d08-4896-a005-51171d8cad5b.png#height=302&id=IqBTz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=2286&originalType=binary&size=70575&status=done&style=stroke&width=2286" alt="image.png"></p><ol start="2"><li><strong>最左前缀法则</strong><blockquote><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引 中的列。</p></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 下列哪些SQL左右索引了，why？</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> age <span class="token operator">=</span> <span class="token number">22</span> <span class="token operator">AND</span> position <span class="token operator">=</span><span class="token string">'manager'</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> position <span class="token operator">=</span> <span class="token string">'manager'</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'LiLei'</span><span class="token punctuation">;</span></code></pre><ol start="3"><li><strong>不在索引列上做任何操作</strong><blockquote><p>比如：计算、函数、（自动 or 手动）类型转换，会导致索引失效而转向全表扫描</p></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'LiLei'</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> <span class="token keyword">left</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'LiLei'</span><span class="token punctuation">;</span></code></pre><ol start="4"><li><strong>存储引擎不能使用索引中范围条件右边的列</strong><blockquote><p>联合索引中当遇到范围查找时右边剩余索引不使用<br>&lt; &gt; &gt;= &lt;= like</p></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 下列SQL会命中哪些索引？why？</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'LiLei'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">22</span> <span class="token operator">AND</span> position <span class="token operator">=</span><span class="token string">'manager'</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'LiLei'</span> <span class="token operator">AND</span> age <span class="token operator">></span> <span class="token number">22</span> <span class="token operator">AND</span> position <span class="token operator">=</span><span class="token string">'manager'</span><span class="token punctuation">;</span></code></pre><ol start="5"><li><strong>尽量使用覆盖索引</strong><blockquote><p>只访问索引的查询（索引列包含查询列），减少 select *语句</p></blockquote></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>age <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'LiLei'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">23</span> <span class="token operator">AND</span> position <span class="token operator">=</span><span class="token string">'manager'</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'LiLei'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">23</span> <span class="token operator">AND</span> position <span class="token operator">=</span><span class="token string">'manager'</span><span class="token punctuation">;</span></code></pre><ol start="6"><li><strong>mysql 在使用不等于（!=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</strong></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">!=</span> <span class="token string">'LiLei'</span><span class="token punctuation">;</span></code></pre><ol start="7"><li><strong>is null,is not null 也无法使用索引</strong></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">is</span> <span class="token boolean">null</span><span class="token punctuation">;</span></code></pre><ol start="8"><li><strong>like 以通配符开头（’$abc…’）mysql 索引失效会变成全表扫描操作</strong></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">like</span> <span class="token string">'%Lei'</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">like</span> <span class="token string">'Lei%'</span><span class="token punctuation">;</span>问题：解决<span class="token operator">like</span><span class="token string">'%字符串%'</span>索引不被使用的方法？<span class="token number">1</span>）使用覆盖索引，查询字段必须是建立覆盖索引字段<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>position <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">like</span> <span class="token string">'%Lei%'</span><span class="token punctuation">;</span><span class="token number">2</span>）如果不能使用覆盖索引则可能需要借助搜索引擎</code></pre><ol start="9"><li><strong>字符串不加单引号索引失效</strong></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'1000'</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span></code></pre><ol start="10"><li><strong>少用 or 或 in，用它查询时，mysql 不一定使用索引，mysql 内部优化器会根据检索比例、 表大小等多个因素整体评估是否使用索引，详见范围查询优化</strong></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'LiLei'</span> <span class="token operator">or</span> name <span class="token operator">=</span> <span class="token string">'HanMeimei'</span><span class="token punctuation">;</span></code></pre><ol start="11"><li><strong>范围查询优化</strong></li></ol><pre class=" language-sql"><code class="language-sql">给年龄添加单值索引<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>employees<span class="token punctuation">`</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> <span class="token punctuation">`</span>idx_age<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>age<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span><span class="token punctuation">;</span><span class="token number">1</span>）eg1:<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">where</span> age <span class="token operator">>=</span><span class="token number">1</span> <span class="token operator">and</span> age <span class="token operator">&lt;=</span><span class="token number">200000</span><span class="token punctuation">;</span>分析：没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索 引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引优化方法：可以讲大的范围拆分成多个小范围<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">where</span> age <span class="token operator">>=</span><span class="token number">1</span> <span class="token operator">and</span> age <span class="token operator">&lt;=</span><span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> employees <span class="token keyword">where</span> age <span class="token operator">>=</span><span class="token number">1001</span> <span class="token operator">and</span> age <span class="token operator">&lt;=</span><span class="token number">2000</span><span class="token punctuation">;</span>还原最初索引状态：<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>employees<span class="token punctuation">`</span> <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> <span class="token punctuation">`</span>idx_age<span class="token punctuation">`</span><span class="token punctuation">;</span></code></pre><ol start="12"><li><strong>索引使用总结</strong><table><thead><tr><th>假设索引为：index(a,b,c)</th><th></th></tr></thead><tbody><tr><td><strong>where 语句</strong></td><td><strong>是否使用了索引，请列举出来</strong></td></tr><tr><td>where a=3</td><td>yes，使用到 a</td></tr><tr><td>where a=3 and b=5</td><td>yes，使用到 a，b</td></tr><tr><td>where a=3 and b=5 and c=4</td><td>yes，使用到 a,b,c</td></tr><tr><td>where b=3 或 where b=3 and c=4 或者 where c=4</td><td>no</td></tr><tr><td>where a=3 and c=5</td><td>yes，使用到 a ，c 不走，被 b 中断了</td></tr><tr><td>where a=3 and b like ‘kk%’ and c=4</td><td>yes，使用到 a,b,c</td></tr><tr><td>where a=3 and b like ‘%kk’ and c=4</td><td>yes，只使用到 a</td></tr><tr><td>where a=3 and b like ‘%kk%’ and c=4</td><td>yes，只使用到 a</td></tr><tr><td>where a=3 and b like ‘k%kk%’ and c=4</td><td>yes，使用到 a,b,c</td></tr><tr><td>说明：like KK%相当于=常量，%KK 和%KK% 相当于范围</td><td></td></tr></tbody></table></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常用容器启动命令集合</title>
      <link href="2020/06/06/Docker%20%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88.html"/>
      <url>2020/06/06/Docker%20%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mongo"><a href="#Mongo" class="headerlink" title="Mongo"></a>Mongo</h1><pre class=" language-shell"><code class="language-shell">docker run -d -p 27017:27017 -v /$PWD/docker/mongo/db:/data/db --restart=always --name mymongo -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin mongo:latest</code></pre><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><pre class=" language-shell"><code class="language-shell">docker run -d --name myredis -p 6379:6379 --restart=always redis --requirepass "redis"</code></pre><h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><pre class=" language-shell"><code class="language-shell">-- 主从搭建模式：Master:docker run -d -p 3306:3306 --privileged=true -v /$PWD/docker/mysql/master/data:/var/lib/mysql -v /$PWD/docker/mysql/master/conf/my.cnf:/etc/mysql/my.cnf --name mysql-master --restart=always -e MYSQL_ROOT_PASSWORD="root" mysql:latestSlave:docker run -d -p 3307:3306 --privileged=true -v /$PWD/docker/mysql/slave/data:/var/lib/mysql -v /$PWD/docker/mysql/slave/conf/my.cnf:/etc/mysql/my.cnf --name mysql-slave --restart=always -e MYSQL_ROOT_PASSWORD="root" mysql:latest</code></pre><pre class=" language-shell"><code class="language-shell"># my.cnf配置如下：[client]default-character-set = utf8mb4[mysql]default-character-set = utf8mb4[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ci# 局域网唯一server-id=100## 开启二进制日志功能（关键）log-bin=mysql-binpid-file        = /var/run/mysqld/mysqld.pidsocket          = /var/run/mysqld/mysqld.sockdatadir         = /var/lib/mysqlsecure-file-priv= NULL# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0# Custom config should go here!includedir /etc/mysql/conf.d/</code></pre><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><pre class=" language-shell"><code class="language-shell">mac os :docker run -d --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2  --name myzookeeper -p 2181:2181 -v /$PWD/docker/zookeeper/data:/data -e TZ=Asia/Shanghai wurstmeister/zookeeperunix:docker run -d --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2  --name myzookeeper -p 2181:2181 -v /etc/localtime:/etc/localtime wurstmeister/zookeeper</code></pre><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><pre class=" language-shell"><code class="language-shell">docker run -d --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2 --name mykafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=127.0.0.1:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://127.0.0.1:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -e TZ=Asia/Shanghai wurstmeister/kafka</code></pre><h1 id="Draw-io"><a href="#Draw-io" class="headerlink" title="Draw.io"></a>Draw.io</h1><pre class=" language-shell"><code class="language-shell">docker run -d -p 8081:8080 --restart=always --hostname=drawio --name mydrawio my-drawio</code></pre><h1 id="ElasticSearch-Kibana"><a href="#ElasticSearch-Kibana" class="headerlink" title="ElasticSearch + Kibana"></a>ElasticSearch + Kibana</h1><pre class=" language-shell"><code class="language-shell">docker run -d --restart=always -p 9200:9200 -p 9300:9300 --network esnet -e "discovery.type=single-node" -v /$PWD/docker/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml --name elasticsearch elasticsearch:7.9.1docker run -d --restart=always -p 5601:5601 --name kibana --network esnet --link elasticsearch:elasticsearch kibana:7.9.1</code></pre><h1 id="nextcloud"><a href="#nextcloud" class="headerlink" title="nextcloud"></a>nextcloud</h1><pre class=" language-shell"><code class="language-shell">docker run --restart=always --name nextcloud -p 10100:80 -v /usr/docker/nextcloud:/var/www/html/data -d nextcloud</code></pre><h1 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h1><pre class=" language-shell"><code class="language-shell">docker run -d -p 2443:443 -p 5678:80 -p 2222:22 --name gitlab --restart always -v /usr/docker/gitlab/config:/etc/gitlab -v /usr/docker/gitlab/logs:/var/log/gitlab -v /usr/docker/gitlab/data:/var/opt/gitlab docker.io/gitlab/gitlab-ce</code></pre><h1 id="gitlab-runner"><a href="#gitlab-runner" class="headerlink" title="gitlab-runner"></a>gitlab-runner</h1><pre class=" language-shell"><code class="language-shell">docker run -d --name gitlab-runner --restart always -v /usr/docker/gitlab-runner/config:/etc/gitlab-runner -v /usr/docker/gitlab-runner/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:latest</code></pre><h1 id="gitlab-runner-docker-compose-yml"><a href="#gitlab-runner-docker-compose-yml" class="headerlink" title="gitlab+runner docker-compose yml"></a>gitlab+runner docker-compose yml</h1><pre class=" language-shell"><code class="language-shell">version: '3.2'services:    gitlab-web:        container_name: gitlab        image: docker.io/gitlab/gitlab-ce        restart: always        hostname: 'gitlab.adotcode.com'        environment:            GITLAB_OMNIBUS_CONFIG: |                external_url 'https://gitlab.adotcode.com:2443'                nginx['redirect_http_to_https'] = true                letsencrypt['enable'] = false                nginx['ssl_certificate'] = "/etc/gitlab/ssl/gitlab.adotcode.com.crt"                nginx['ssl_certificate_key'] = "/etc/gitlab/ssl/gitlab.adotcode.com.key"                gitlab_rails['time_zone'] = 'Asia/Shanghai'                gitlab_rails['gitlab_shell_ssh_port'] = 2222                # Add any other gitlab.rb configuration here, each on its own line        ports:            - '2443:2443'            - '2222:22'            - '5678:80'        volumes:            - /usr/docker/gitlab/config:/etc/gitlab            - /usr/docker/gitlab/logs:/var/log/gitlab            - /usr/docker/gitlab/data:/var/opt/gitlab            - /usr/docker/gitlab/ssl:/etc/gitlab/ssl        networks:            - gitlab-ce-network    gitlab-runner:        container_name: gitlab-runner-public        image: gitlab/gitlab-runner:latest        restart: always        depends_on:            - gitlab-web        volumes:            - /usr/docker/gitlab-runner-public/config:/etc/gitlab-runner            - /var/run/docker.sock:/var/run/docker.sock        network_mode: "host"networks:    gitlab-ce-network:        name: gitlab-ce-network# runner config.tomlconcurrent = 1check_interval = 0[session_server]  session_timeout = 1800[[runners]]  name = "gitlab runner public"  url = "https://gitlab.adotcode.com:2443/"  token = "Z-4kYz9QosxVWSHNjU5K"  executor = "docker"  [runners.custom_build_dir]  [runners.cache]    [runners.cache.s3]    [runners.cache.gcs]    [runners.cache.azure]  [runners.docker]    extra_hosts = ["gitlab.adotcode.com:192.168.1.6"]    tls_verify = false    image = "docker:19.03.12"    privileged = false    disable_entrypoint_overwrite = false    oom_kill_disable = false    disable_cache = false    volumes = ["/var/run/docker.sock:/var/run/docker.sock", "/cache"]    shm_size = 0 # 后台 启动sudo docker-compose up -d# 停止会删除容器docker-compose down# 停止不会删除容器docker-compose stop</code></pre><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><pre class=" language-shell"><code class="language-shell">docker run -d --restart always --name nginx -p 80:80 -v /usr/docker/nginx/nginx.conf:/etc/nginx/nginx.conf -v /usr/docker/nginx/ssl:/etc/nginx/ssl -v /usr/docker/nginx/logs:/var/log/nginx -v /usr/docker/nginx/html:/usr/share/nginx/html -v /usr/docker/nginx/conf:/etc/nginx/conf.d --privileged=true nginx</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java List 操作</title>
      <link href="2019/07/11/java%20List%20%E6%93%8D%E4%BD%9C.html"/>
      <url>2019/07/11/java%20List%20%E6%93%8D%E4%BD%9C.html</url>
      
        <content type="html"><![CDATA[<p>1 列表转换及字符串 joining</p><pre class=" language-java"><code class="language-java"> List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> pathCodes <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"pathCodes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String pathCodeLikeWhere <span class="token operator">=</span> pathCodes                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>obj <span class="token operator">-</span><span class="token operator">></span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Ancestor LIKE '%s%%'"</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">" OR "</span><span class="token punctuation">,</span> <span class="token string">"("</span><span class="token punctuation">,</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 结果："(Ancestor LIKE 'xxx%' OR Ancestor LIKE 'xxxxx%')"</span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>发布自己的程序包到nuget.org</title>
      <link href="2019/06/12/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%88%B0nuget.org.html"/>
      <url>2019/06/12/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%88%B0nuget.org.html</url>
      
        <content type="html"><![CDATA[<h2 id="登录NuGet"><a href="#登录NuGet" class="headerlink" title="登录NuGet"></a>登录<a href="https://www.nuget.org/">NuGet</a></h2><p>没有账号自己注册</p><h2 id="申请-ApiKey"><a href="#申请-ApiKey" class="headerlink" title="申请 ApiKey"></a>申请 ApiKey</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/105968/1560349730833-a8cc7ba2-3ffe-49fc-9397-8b641bf3e25a.png#align=left&display=inline&height=347&name=image.png&originHeight=1386&originWidth=2560&size=195033&status=done&width=640" alt="image.png"></p><h2 id="下载nuget-exe-配置环境变量"><a href="#下载nuget-exe-配置环境变量" class="headerlink" title="下载nuget.exe, 配置环境变量"></a>下载<a href="https://www.nuget.org/downloads">nuget.exe</a>, 配置环境变量</h2><p>在系统环境变量 path 中新增 nuget.exe 所在目录位置，如：D:\Tools\nuget<br>测试：在 cmd 中输入 nuget 回车 看看是否能识别</p><h2 id="设置-nuget-的-ApiKey"><a href="#设置-nuget-的-ApiKey" class="headerlink" title="设置 nuget 的 ApiKey"></a>设置 nuget 的 ApiKey</h2><p>为了能上传需要设置 apikey 上面所申请的 key<br>在 cmd 中输入命令 nuget setApiKey xxxxxxxxxxxxxxx 回车即可。</p><h2 id="发布包到-nuget-org"><a href="#发布包到-nuget-org" class="headerlink" title="发布包到 nuget.org"></a>发布包到 nuget.org</h2><p>在 cmd 中进入到在包所在目录中<br>输入命令   nuget push xxxxxx.nupkg -Source <a href="https://api.nuget.org/v3/index.json">https://api.nuget.org/v3/index.json</a> 回车 。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
